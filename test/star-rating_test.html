<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>star-rating test</title>

    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../../mocha/mocha.js"></script>
    <script src="../../../chai/chai.js"></script>
    <script src="../../../wct-mocha/wct-mocha.js"></script>

    <script type="module" src="../star-rating.js"></script>
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <star-rating></star-rating>
      </template>
    </test-fixture>

    <test-fixture id="Selected">
      <template>
        <star-rating value="3"></star-rating>
      </template>
    </test-fixture>

    <test-fixture id="Readonly">
      <template>
        <star-rating readonly></star-rating>
      </template>
    </test-fixture>

    <script type="module">
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    import {click, keyDownOn} from '../../../@polymer/iron-test-helpers/mock-interactions.js'
    suite('Constructor', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Sets __data__ proeprty', () => {
        assert.typeOf(element.__data__, 'object');
      });

      test('Attaches shadow DOM', () => {
        assert.ok(element.shadowRoot.querySelector('#container'));
      });
    });

    suite('observedAttributes()', () => {
      [
        'readonly',
        'value'
      ].forEach((attr) => {
        test('Observes ' + attr, () => {
          const list = window.customElements.get('star-rating').observedAttributes;
          assert.notEqual(list.indexOf(attr), -1);
        });
      });
    });

    suite('value setter/getter', () => {
      test('Sets value on __data__', () => {
        const element = fixture('Basic');
        element.value = 1;
        assert.equal(element.__data__.value, 1);
      });

      test('Sets attribute', () => {
        const element = fixture('Basic');
        element.value = 2;
        assert.equal(element.getAttribute('value'), '2');
      });

      test('Convents value to a number', () => {
        const element = fixture('Basic');
        element.value = '2';
        assert.equal(element.__data__.value, 2);
      });

      test('Sets 0 when not a number', () => {
        const element = fixture('Basic');
        element.value = 'test';
        assert.equal(element.__data__.value, 0);
      });

      test('Won\'t set attribute value when already set', () => {
        const element = fixture('Selected');
        const spy = sinon.spy(element, 'setAttribute');
        element.value = 3;
        element.setAttribute.restore();
        assert.isFalse(spy.called);
      });

      test('Calls _render() when value change', () => {
        const element = fixture('Basic');
        const spy = sinon.spy(element, '_render');
        element.value = 3;
        element._render.restore();
        assert.isTrue(spy.called);
      });

      test('Getter returns a value', () => {
        const element = fixture('Selected');
        element.value = 2;
        assert.equal(element.value, 2);
      });

      test('Removes attribute when value is undefined', () => {
        const element = fixture('Selected');
        element.value = undefined;
        assert.isFalse(element.hasAttribute('value'));
      });

      test('Removes attribute when value is null', () => {
        const element = fixture('Selected');
        element.value = null;
        assert.isFalse(element.hasAttribute('value'));
      });
    });

    suite('readonly setter/getter', () => {
      test('Attribute sets the property', () => {
        const element = fixture('Readonly');
        assert.isTrue(element.readonly);
      });

      test('Getter returns default value', () => {
        const element = fixture('Basic');
        assert.isFalse(element.readonly);
      });

      test('Setting the property set the attribute', () => {
        const element = fixture('Basic');
        element.readonly = true;
        assert.isTrue(element.hasAttribute('readonly'));
      });

      test('False removes the attribute', () => {
        const element = fixture('Readonly');
        element.readonly = false;
        assert.isFalse(element.hasAttribute('readonly'));
      });

      test('Calls _render() when value change', () => {
        const element = fixture('Basic');
        const spy = sinon.spy(element, '_render');
        element.readonly = true;
        element._render.restore();
        assert.isTrue(spy.called);
      });
    });

    suite('_render()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        setTimeout(() => done());
      });

      test('Sets __rendering', () => {
        element._render();
        assert.isTrue(element.__rendering);
      });

      test('Eventually calls _doRender()', (done) => {
        const spy = sinon.spy(element, '_doRender');
        element._render();
        setTimeout(() => {
          element._doRender.restore();
          assert.isTrue(spy.called);
          done();
        });
      });

      test('Eventually resets __rendering', (done) => {
        element._render();
        setTimeout(() => {
          assert.isFalse(element.__rendering);
          done();
        });
      });
    });

    suite('_createStar()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        setTimeout(() => done());
      });

      test('Returns svg element', () => {
        const result = element._createStar();
        assert.equal(result.nodeName.toLowerCase(), 'svg');
      });

      test('Has viewBox attribute', () => {
        const result = element._createStar();
        assert.equal(result.getAttribute('viewBox'), '0 0 24 24');
      });

      test('Has tabindex attribute', () => {
        const result = element._createStar();
        assert.equal(result.getAttribute('tabindex'), '0');
      });
    });

    suite('_ensureStars()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        setTimeout(() => done());
      });

      // This function is called when the element is attached and later on it
      // won't be executed

      test('Stars are in the shadow DOM', () => {
        const stars = element.shadowRoot.querySelectorAll('#container .star');
        assert.lengthOf(stars, 5);
      });

      test('Inserts stars only once', () => {
        element._ensureStars();
        const stars = element.shadowRoot.querySelectorAll('#container .star');
        assert.lengthOf(stars, 5);
      });

      test('Star has class name', () => {
        const star = element.shadowRoot.querySelector('#container .star');
        assert.isTrue(star.classList.contains('star'));
      });

      test('Star has data-index property', () => {
        const star = element.shadowRoot.querySelector('#container .star');
        assert.equal(star.dataset.index, '0');
      });
    });

    suite('_doRender()', () => {
      let element;
      setup((done) => {
        element = fixture('Selected');
        setTimeout(() => done());
      });

      test('Calls _ensureStars()', () => {
        const spy = sinon.spy(element, '_ensureStars');
        element._doRender();
        element._ensureStars.restore();
        assert.isTrue(spy.called);
      });

      test('Removes selected class', () => {
        element.value = 2;
        element._doRender();
        const stars = element.shadowRoot.querySelectorAll('#container .star');
        assert.isFalse(stars[2].classList.contains('selected'));
      });

      test('Sets stars selected', () => {
        const stars = element.shadowRoot.querySelectorAll('#container .star.selected');
        assert.lengthOf(stars, 3);
      });

      test('Updates tabindex', () => {
        element.readonly = true;
        element._doRender();
        const star = element.shadowRoot.querySelector('#container .star');
        assert.equal(star.getAttribute('tabindex'), '-1');
      });
    });

    suite('_clickHandler()', () => {
      let element;
      setup((done) => {
        element = fixture('Selected');
        setTimeout(() => done());
      });

      test('Calls _selectionFromEvent()', () => {
        const spy = sinon.spy(element, '_selectionFromEvent');
        element.click();
        element._selectionFromEvent.restore();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _selectionFromEvent() when readonly', () => {
        element.readonly = true;
        const spy = sinon.spy(element, '_selectionFromEvent');
        element.click();
        element._selectionFromEvent.restore();
        assert.isFalse(spy.called);
      });

      test('Star click changes value', () => {
        const star = element.shadowRoot.querySelector('.star');
        click(star);
        assert.equal(element.value, 1);
      });

      test('Dispatches value-changed event', () => {
        const spy = sinon.spy();
        element.addEventListener('value-changed', spy);
        const star = element.shadowRoot.querySelector('.star');
        click(star);
        assert.equal(spy.args[0][0].detail.value, 1);
      });
    });

    suite('_clickHandler()', () => {
      let element;
      setup((done) => {
        element = fixture('Selected');
        setTimeout(() => done());
      });

      test('Calls _selectionFromEvent() for Space', () => {
        const spy = sinon.spy(element, '_selectionFromEvent');
        keyDownOn(element, 'Space');
        element._selectionFromEvent.restore();
        assert.isTrue(spy.called);
      });

      test('Calls _selectionFromEvent() for Enter', () => {
        const spy = sinon.spy(element, '_selectionFromEvent');
        keyDownOn(element, 'Enter');
        element._selectionFromEvent.restore();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _selectionFromEvent() for other keys', () => {
        const spy = sinon.spy(element, '_selectionFromEvent');
        keyDownOn(element, 'S');
        element._selectionFromEvent.restore();
        assert.isFalse(spy.called);
      });

      test('Won\'t call _selectionFromEvent() when readonly', () => {
        element.readonly = true;
        const spy = sinon.spy(element, '_selectionFromEvent');
        keyDownOn(element, 'Enter');
        element._selectionFromEvent.restore();
        assert.isFalse(spy.called);
      });

      test('Changes value', () => {
        const star = element.shadowRoot.querySelector('.star');
        keyDownOn(star, 'Enter');
        assert.equal(element.value, 1);
      });

      test('Dispatches value-changed event', () => {
        const spy = sinon.spy();
        element.addEventListener('value-changed', spy);
        const star = element.shadowRoot.querySelector('.star');
        keyDownOn(star, 'Enter');
        assert.equal(spy.args[0][0].detail.value, 1);
      });
    });
    </script>

  </body>
</html>
